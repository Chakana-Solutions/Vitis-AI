// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: second/protos/optimizer.proto

#ifndef PROTOBUF_second_2fprotos_2foptimizer_2eproto__INCLUDED
#define PROTOBUF_second_2fprotos_2foptimizer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace second {
namespace protos {
class AdamOptimizer;
class AdamOptimizerDefaultTypeInternal;
extern AdamOptimizerDefaultTypeInternal _AdamOptimizer_default_instance_;
class ConstantLearningRate;
class ConstantLearningRateDefaultTypeInternal;
extern ConstantLearningRateDefaultTypeInternal _ConstantLearningRate_default_instance_;
class CosineDecayLearningRate;
class CosineDecayLearningRateDefaultTypeInternal;
extern CosineDecayLearningRateDefaultTypeInternal _CosineDecayLearningRate_default_instance_;
class ExponentialDecayLearningRate;
class ExponentialDecayLearningRateDefaultTypeInternal;
extern ExponentialDecayLearningRateDefaultTypeInternal _ExponentialDecayLearningRate_default_instance_;
class LearningRate;
class LearningRateDefaultTypeInternal;
extern LearningRateDefaultTypeInternal _LearningRate_default_instance_;
class ManualStepLearningRate;
class ManualStepLearningRateDefaultTypeInternal;
extern ManualStepLearningRateDefaultTypeInternal _ManualStepLearningRate_default_instance_;
class ManualStepLearningRate_LearningRateSchedule;
class ManualStepLearningRate_LearningRateScheduleDefaultTypeInternal;
extern ManualStepLearningRate_LearningRateScheduleDefaultTypeInternal _ManualStepLearningRate_LearningRateSchedule_default_instance_;
class MomentumOptimizer;
class MomentumOptimizerDefaultTypeInternal;
extern MomentumOptimizerDefaultTypeInternal _MomentumOptimizer_default_instance_;
class Optimizer;
class OptimizerDefaultTypeInternal;
extern OptimizerDefaultTypeInternal _Optimizer_default_instance_;
class RMSPropOptimizer;
class RMSPropOptimizerDefaultTypeInternal;
extern RMSPropOptimizerDefaultTypeInternal _RMSPropOptimizer_default_instance_;
}  // namespace protos
}  // namespace second

namespace second {
namespace protos {

namespace protobuf_second_2fprotos_2foptimizer_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_second_2fprotos_2foptimizer_2eproto

// ===================================================================

class Optimizer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:second.protos.Optimizer) */ {
 public:
  Optimizer();
  virtual ~Optimizer();

  Optimizer(const Optimizer& from);

  inline Optimizer& operator=(const Optimizer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optimizer(Optimizer&& from) noexcept
    : Optimizer() {
    *this = ::std::move(from);
  }

  inline Optimizer& operator=(Optimizer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Optimizer& default_instance();

  enum OptimizerCase {
    kRmsPropOptimizer = 1,
    kMomentumOptimizer = 2,
    kAdamOptimizer = 3,
    OPTIMIZER_NOT_SET = 0,
  };

  static inline const Optimizer* internal_default_instance() {
    return reinterpret_cast<const Optimizer*>(
               &_Optimizer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Optimizer* other);
  friend void swap(Optimizer& a, Optimizer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optimizer* New() const PROTOBUF_FINAL { return New(NULL); }

  Optimizer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Optimizer& from);
  void MergeFrom(const Optimizer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Optimizer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool use_moving_average = 4;
  void clear_use_moving_average();
  static const int kUseMovingAverageFieldNumber = 4;
  bool use_moving_average() const;
  void set_use_moving_average(bool value);

  // float moving_average_decay = 5;
  void clear_moving_average_decay();
  static const int kMovingAverageDecayFieldNumber = 5;
  float moving_average_decay() const;
  void set_moving_average_decay(float value);

  // .second.protos.RMSPropOptimizer rms_prop_optimizer = 1;
  bool has_rms_prop_optimizer() const;
  void clear_rms_prop_optimizer();
  static const int kRmsPropOptimizerFieldNumber = 1;
  const ::second::protos::RMSPropOptimizer& rms_prop_optimizer() const;
  ::second::protos::RMSPropOptimizer* mutable_rms_prop_optimizer();
  ::second::protos::RMSPropOptimizer* release_rms_prop_optimizer();
  void set_allocated_rms_prop_optimizer(::second::protos::RMSPropOptimizer* rms_prop_optimizer);

  // .second.protos.MomentumOptimizer momentum_optimizer = 2;
  bool has_momentum_optimizer() const;
  void clear_momentum_optimizer();
  static const int kMomentumOptimizerFieldNumber = 2;
  const ::second::protos::MomentumOptimizer& momentum_optimizer() const;
  ::second::protos::MomentumOptimizer* mutable_momentum_optimizer();
  ::second::protos::MomentumOptimizer* release_momentum_optimizer();
  void set_allocated_momentum_optimizer(::second::protos::MomentumOptimizer* momentum_optimizer);

  // .second.protos.AdamOptimizer adam_optimizer = 3;
  bool has_adam_optimizer() const;
  void clear_adam_optimizer();
  static const int kAdamOptimizerFieldNumber = 3;
  const ::second::protos::AdamOptimizer& adam_optimizer() const;
  ::second::protos::AdamOptimizer* mutable_adam_optimizer();
  ::second::protos::AdamOptimizer* release_adam_optimizer();
  void set_allocated_adam_optimizer(::second::protos::AdamOptimizer* adam_optimizer);

  OptimizerCase optimizer_case() const;
  // @@protoc_insertion_point(class_scope:second.protos.Optimizer)
 private:
  void set_has_rms_prop_optimizer();
  void set_has_momentum_optimizer();
  void set_has_adam_optimizer();

  inline bool has_optimizer() const;
  void clear_optimizer();
  inline void clear_has_optimizer();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool use_moving_average_;
  float moving_average_decay_;
  union OptimizerUnion {
    OptimizerUnion() {}
    ::second::protos::RMSPropOptimizer* rms_prop_optimizer_;
    ::second::protos::MomentumOptimizer* momentum_optimizer_;
    ::second::protos::AdamOptimizer* adam_optimizer_;
  } optimizer_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_second_2fprotos_2foptimizer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RMSPropOptimizer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:second.protos.RMSPropOptimizer) */ {
 public:
  RMSPropOptimizer();
  virtual ~RMSPropOptimizer();

  RMSPropOptimizer(const RMSPropOptimizer& from);

  inline RMSPropOptimizer& operator=(const RMSPropOptimizer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RMSPropOptimizer(RMSPropOptimizer&& from) noexcept
    : RMSPropOptimizer() {
    *this = ::std::move(from);
  }

  inline RMSPropOptimizer& operator=(RMSPropOptimizer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RMSPropOptimizer& default_instance();

  static inline const RMSPropOptimizer* internal_default_instance() {
    return reinterpret_cast<const RMSPropOptimizer*>(
               &_RMSPropOptimizer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RMSPropOptimizer* other);
  friend void swap(RMSPropOptimizer& a, RMSPropOptimizer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RMSPropOptimizer* New() const PROTOBUF_FINAL { return New(NULL); }

  RMSPropOptimizer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RMSPropOptimizer& from);
  void MergeFrom(const RMSPropOptimizer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RMSPropOptimizer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .second.protos.LearningRate learning_rate = 1;
  bool has_learning_rate() const;
  void clear_learning_rate();
  static const int kLearningRateFieldNumber = 1;
  const ::second::protos::LearningRate& learning_rate() const;
  ::second::protos::LearningRate* mutable_learning_rate();
  ::second::protos::LearningRate* release_learning_rate();
  void set_allocated_learning_rate(::second::protos::LearningRate* learning_rate);

  // float momentum_optimizer_value = 2;
  void clear_momentum_optimizer_value();
  static const int kMomentumOptimizerValueFieldNumber = 2;
  float momentum_optimizer_value() const;
  void set_momentum_optimizer_value(float value);

  // float decay = 3;
  void clear_decay();
  static const int kDecayFieldNumber = 3;
  float decay() const;
  void set_decay(float value);

  // float epsilon = 4;
  void clear_epsilon();
  static const int kEpsilonFieldNumber = 4;
  float epsilon() const;
  void set_epsilon(float value);

  // float weight_decay = 5;
  void clear_weight_decay();
  static const int kWeightDecayFieldNumber = 5;
  float weight_decay() const;
  void set_weight_decay(float value);

  // @@protoc_insertion_point(class_scope:second.protos.RMSPropOptimizer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::second::protos::LearningRate* learning_rate_;
  float momentum_optimizer_value_;
  float decay_;
  float epsilon_;
  float weight_decay_;
  mutable int _cached_size_;
  friend struct protobuf_second_2fprotos_2foptimizer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MomentumOptimizer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:second.protos.MomentumOptimizer) */ {
 public:
  MomentumOptimizer();
  virtual ~MomentumOptimizer();

  MomentumOptimizer(const MomentumOptimizer& from);

  inline MomentumOptimizer& operator=(const MomentumOptimizer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MomentumOptimizer(MomentumOptimizer&& from) noexcept
    : MomentumOptimizer() {
    *this = ::std::move(from);
  }

  inline MomentumOptimizer& operator=(MomentumOptimizer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MomentumOptimizer& default_instance();

  static inline const MomentumOptimizer* internal_default_instance() {
    return reinterpret_cast<const MomentumOptimizer*>(
               &_MomentumOptimizer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(MomentumOptimizer* other);
  friend void swap(MomentumOptimizer& a, MomentumOptimizer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MomentumOptimizer* New() const PROTOBUF_FINAL { return New(NULL); }

  MomentumOptimizer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MomentumOptimizer& from);
  void MergeFrom(const MomentumOptimizer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MomentumOptimizer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .second.protos.LearningRate learning_rate = 1;
  bool has_learning_rate() const;
  void clear_learning_rate();
  static const int kLearningRateFieldNumber = 1;
  const ::second::protos::LearningRate& learning_rate() const;
  ::second::protos::LearningRate* mutable_learning_rate();
  ::second::protos::LearningRate* release_learning_rate();
  void set_allocated_learning_rate(::second::protos::LearningRate* learning_rate);

  // float momentum_optimizer_value = 2;
  void clear_momentum_optimizer_value();
  static const int kMomentumOptimizerValueFieldNumber = 2;
  float momentum_optimizer_value() const;
  void set_momentum_optimizer_value(float value);

  // float weight_decay = 3;
  void clear_weight_decay();
  static const int kWeightDecayFieldNumber = 3;
  float weight_decay() const;
  void set_weight_decay(float value);

  // @@protoc_insertion_point(class_scope:second.protos.MomentumOptimizer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::second::protos::LearningRate* learning_rate_;
  float momentum_optimizer_value_;
  float weight_decay_;
  mutable int _cached_size_;
  friend struct protobuf_second_2fprotos_2foptimizer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AdamOptimizer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:second.protos.AdamOptimizer) */ {
 public:
  AdamOptimizer();
  virtual ~AdamOptimizer();

  AdamOptimizer(const AdamOptimizer& from);

  inline AdamOptimizer& operator=(const AdamOptimizer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdamOptimizer(AdamOptimizer&& from) noexcept
    : AdamOptimizer() {
    *this = ::std::move(from);
  }

  inline AdamOptimizer& operator=(AdamOptimizer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AdamOptimizer& default_instance();

  static inline const AdamOptimizer* internal_default_instance() {
    return reinterpret_cast<const AdamOptimizer*>(
               &_AdamOptimizer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(AdamOptimizer* other);
  friend void swap(AdamOptimizer& a, AdamOptimizer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdamOptimizer* New() const PROTOBUF_FINAL { return New(NULL); }

  AdamOptimizer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AdamOptimizer& from);
  void MergeFrom(const AdamOptimizer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AdamOptimizer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .second.protos.LearningRate learning_rate = 1;
  bool has_learning_rate() const;
  void clear_learning_rate();
  static const int kLearningRateFieldNumber = 1;
  const ::second::protos::LearningRate& learning_rate() const;
  ::second::protos::LearningRate* mutable_learning_rate();
  ::second::protos::LearningRate* release_learning_rate();
  void set_allocated_learning_rate(::second::protos::LearningRate* learning_rate);

  // float weight_decay = 2;
  void clear_weight_decay();
  static const int kWeightDecayFieldNumber = 2;
  float weight_decay() const;
  void set_weight_decay(float value);

  // @@protoc_insertion_point(class_scope:second.protos.AdamOptimizer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::second::protos::LearningRate* learning_rate_;
  float weight_decay_;
  mutable int _cached_size_;
  friend struct protobuf_second_2fprotos_2foptimizer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LearningRate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:second.protos.LearningRate) */ {
 public:
  LearningRate();
  virtual ~LearningRate();

  LearningRate(const LearningRate& from);

  inline LearningRate& operator=(const LearningRate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LearningRate(LearningRate&& from) noexcept
    : LearningRate() {
    *this = ::std::move(from);
  }

  inline LearningRate& operator=(LearningRate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LearningRate& default_instance();

  enum LearningRateCase {
    kConstantLearningRate = 1,
    kExponentialDecayLearningRate = 2,
    kManualStepLearningRate = 3,
    kCosineDecayLearningRate = 4,
    LEARNING_RATE_NOT_SET = 0,
  };

  static inline const LearningRate* internal_default_instance() {
    return reinterpret_cast<const LearningRate*>(
               &_LearningRate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(LearningRate* other);
  friend void swap(LearningRate& a, LearningRate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LearningRate* New() const PROTOBUF_FINAL { return New(NULL); }

  LearningRate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LearningRate& from);
  void MergeFrom(const LearningRate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LearningRate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .second.protos.ConstantLearningRate constant_learning_rate = 1;
  bool has_constant_learning_rate() const;
  void clear_constant_learning_rate();
  static const int kConstantLearningRateFieldNumber = 1;
  const ::second::protos::ConstantLearningRate& constant_learning_rate() const;
  ::second::protos::ConstantLearningRate* mutable_constant_learning_rate();
  ::second::protos::ConstantLearningRate* release_constant_learning_rate();
  void set_allocated_constant_learning_rate(::second::protos::ConstantLearningRate* constant_learning_rate);

  // .second.protos.ExponentialDecayLearningRate exponential_decay_learning_rate = 2;
  bool has_exponential_decay_learning_rate() const;
  void clear_exponential_decay_learning_rate();
  static const int kExponentialDecayLearningRateFieldNumber = 2;
  const ::second::protos::ExponentialDecayLearningRate& exponential_decay_learning_rate() const;
  ::second::protos::ExponentialDecayLearningRate* mutable_exponential_decay_learning_rate();
  ::second::protos::ExponentialDecayLearningRate* release_exponential_decay_learning_rate();
  void set_allocated_exponential_decay_learning_rate(::second::protos::ExponentialDecayLearningRate* exponential_decay_learning_rate);

  // .second.protos.ManualStepLearningRate manual_step_learning_rate = 3;
  bool has_manual_step_learning_rate() const;
  void clear_manual_step_learning_rate();
  static const int kManualStepLearningRateFieldNumber = 3;
  const ::second::protos::ManualStepLearningRate& manual_step_learning_rate() const;
  ::second::protos::ManualStepLearningRate* mutable_manual_step_learning_rate();
  ::second::protos::ManualStepLearningRate* release_manual_step_learning_rate();
  void set_allocated_manual_step_learning_rate(::second::protos::ManualStepLearningRate* manual_step_learning_rate);

  // .second.protos.CosineDecayLearningRate cosine_decay_learning_rate = 4;
  bool has_cosine_decay_learning_rate() const;
  void clear_cosine_decay_learning_rate();
  static const int kCosineDecayLearningRateFieldNumber = 4;
  const ::second::protos::CosineDecayLearningRate& cosine_decay_learning_rate() const;
  ::second::protos::CosineDecayLearningRate* mutable_cosine_decay_learning_rate();
  ::second::protos::CosineDecayLearningRate* release_cosine_decay_learning_rate();
  void set_allocated_cosine_decay_learning_rate(::second::protos::CosineDecayLearningRate* cosine_decay_learning_rate);

  LearningRateCase learning_rate_case() const;
  // @@protoc_insertion_point(class_scope:second.protos.LearningRate)
 private:
  void set_has_constant_learning_rate();
  void set_has_exponential_decay_learning_rate();
  void set_has_manual_step_learning_rate();
  void set_has_cosine_decay_learning_rate();

  inline bool has_learning_rate() const;
  void clear_learning_rate();
  inline void clear_has_learning_rate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union LearningRateUnion {
    LearningRateUnion() {}
    ::second::protos::ConstantLearningRate* constant_learning_rate_;
    ::second::protos::ExponentialDecayLearningRate* exponential_decay_learning_rate_;
    ::second::protos::ManualStepLearningRate* manual_step_learning_rate_;
    ::second::protos::CosineDecayLearningRate* cosine_decay_learning_rate_;
  } learning_rate_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_second_2fprotos_2foptimizer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConstantLearningRate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:second.protos.ConstantLearningRate) */ {
 public:
  ConstantLearningRate();
  virtual ~ConstantLearningRate();

  ConstantLearningRate(const ConstantLearningRate& from);

  inline ConstantLearningRate& operator=(const ConstantLearningRate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConstantLearningRate(ConstantLearningRate&& from) noexcept
    : ConstantLearningRate() {
    *this = ::std::move(from);
  }

  inline ConstantLearningRate& operator=(ConstantLearningRate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConstantLearningRate& default_instance();

  static inline const ConstantLearningRate* internal_default_instance() {
    return reinterpret_cast<const ConstantLearningRate*>(
               &_ConstantLearningRate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ConstantLearningRate* other);
  friend void swap(ConstantLearningRate& a, ConstantLearningRate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConstantLearningRate* New() const PROTOBUF_FINAL { return New(NULL); }

  ConstantLearningRate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConstantLearningRate& from);
  void MergeFrom(const ConstantLearningRate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConstantLearningRate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float learning_rate = 1;
  void clear_learning_rate();
  static const int kLearningRateFieldNumber = 1;
  float learning_rate() const;
  void set_learning_rate(float value);

  // @@protoc_insertion_point(class_scope:second.protos.ConstantLearningRate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float learning_rate_;
  mutable int _cached_size_;
  friend struct protobuf_second_2fprotos_2foptimizer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExponentialDecayLearningRate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:second.protos.ExponentialDecayLearningRate) */ {
 public:
  ExponentialDecayLearningRate();
  virtual ~ExponentialDecayLearningRate();

  ExponentialDecayLearningRate(const ExponentialDecayLearningRate& from);

  inline ExponentialDecayLearningRate& operator=(const ExponentialDecayLearningRate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExponentialDecayLearningRate(ExponentialDecayLearningRate&& from) noexcept
    : ExponentialDecayLearningRate() {
    *this = ::std::move(from);
  }

  inline ExponentialDecayLearningRate& operator=(ExponentialDecayLearningRate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExponentialDecayLearningRate& default_instance();

  static inline const ExponentialDecayLearningRate* internal_default_instance() {
    return reinterpret_cast<const ExponentialDecayLearningRate*>(
               &_ExponentialDecayLearningRate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ExponentialDecayLearningRate* other);
  friend void swap(ExponentialDecayLearningRate& a, ExponentialDecayLearningRate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExponentialDecayLearningRate* New() const PROTOBUF_FINAL { return New(NULL); }

  ExponentialDecayLearningRate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExponentialDecayLearningRate& from);
  void MergeFrom(const ExponentialDecayLearningRate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExponentialDecayLearningRate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float initial_learning_rate = 1;
  void clear_initial_learning_rate();
  static const int kInitialLearningRateFieldNumber = 1;
  float initial_learning_rate() const;
  void set_initial_learning_rate(float value);

  // uint32 decay_steps = 2;
  void clear_decay_steps();
  static const int kDecayStepsFieldNumber = 2;
  ::google::protobuf::uint32 decay_steps() const;
  void set_decay_steps(::google::protobuf::uint32 value);

  // float decay_factor = 3;
  void clear_decay_factor();
  static const int kDecayFactorFieldNumber = 3;
  float decay_factor() const;
  void set_decay_factor(float value);

  // bool staircase = 4;
  void clear_staircase();
  static const int kStaircaseFieldNumber = 4;
  bool staircase() const;
  void set_staircase(bool value);

  // @@protoc_insertion_point(class_scope:second.protos.ExponentialDecayLearningRate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float initial_learning_rate_;
  ::google::protobuf::uint32 decay_steps_;
  float decay_factor_;
  bool staircase_;
  mutable int _cached_size_;
  friend struct protobuf_second_2fprotos_2foptimizer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ManualStepLearningRate_LearningRateSchedule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:second.protos.ManualStepLearningRate.LearningRateSchedule) */ {
 public:
  ManualStepLearningRate_LearningRateSchedule();
  virtual ~ManualStepLearningRate_LearningRateSchedule();

  ManualStepLearningRate_LearningRateSchedule(const ManualStepLearningRate_LearningRateSchedule& from);

  inline ManualStepLearningRate_LearningRateSchedule& operator=(const ManualStepLearningRate_LearningRateSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ManualStepLearningRate_LearningRateSchedule(ManualStepLearningRate_LearningRateSchedule&& from) noexcept
    : ManualStepLearningRate_LearningRateSchedule() {
    *this = ::std::move(from);
  }

  inline ManualStepLearningRate_LearningRateSchedule& operator=(ManualStepLearningRate_LearningRateSchedule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ManualStepLearningRate_LearningRateSchedule& default_instance();

  static inline const ManualStepLearningRate_LearningRateSchedule* internal_default_instance() {
    return reinterpret_cast<const ManualStepLearningRate_LearningRateSchedule*>(
               &_ManualStepLearningRate_LearningRateSchedule_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ManualStepLearningRate_LearningRateSchedule* other);
  friend void swap(ManualStepLearningRate_LearningRateSchedule& a, ManualStepLearningRate_LearningRateSchedule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ManualStepLearningRate_LearningRateSchedule* New() const PROTOBUF_FINAL { return New(NULL); }

  ManualStepLearningRate_LearningRateSchedule* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ManualStepLearningRate_LearningRateSchedule& from);
  void MergeFrom(const ManualStepLearningRate_LearningRateSchedule& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ManualStepLearningRate_LearningRateSchedule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 step = 1;
  void clear_step();
  static const int kStepFieldNumber = 1;
  ::google::protobuf::uint32 step() const;
  void set_step(::google::protobuf::uint32 value);

  // float learning_rate = 2;
  void clear_learning_rate();
  static const int kLearningRateFieldNumber = 2;
  float learning_rate() const;
  void set_learning_rate(float value);

  // @@protoc_insertion_point(class_scope:second.protos.ManualStepLearningRate.LearningRateSchedule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 step_;
  float learning_rate_;
  mutable int _cached_size_;
  friend struct protobuf_second_2fprotos_2foptimizer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ManualStepLearningRate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:second.protos.ManualStepLearningRate) */ {
 public:
  ManualStepLearningRate();
  virtual ~ManualStepLearningRate();

  ManualStepLearningRate(const ManualStepLearningRate& from);

  inline ManualStepLearningRate& operator=(const ManualStepLearningRate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ManualStepLearningRate(ManualStepLearningRate&& from) noexcept
    : ManualStepLearningRate() {
    *this = ::std::move(from);
  }

  inline ManualStepLearningRate& operator=(ManualStepLearningRate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ManualStepLearningRate& default_instance();

  static inline const ManualStepLearningRate* internal_default_instance() {
    return reinterpret_cast<const ManualStepLearningRate*>(
               &_ManualStepLearningRate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ManualStepLearningRate* other);
  friend void swap(ManualStepLearningRate& a, ManualStepLearningRate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ManualStepLearningRate* New() const PROTOBUF_FINAL { return New(NULL); }

  ManualStepLearningRate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ManualStepLearningRate& from);
  void MergeFrom(const ManualStepLearningRate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ManualStepLearningRate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ManualStepLearningRate_LearningRateSchedule LearningRateSchedule;

  // accessors -------------------------------------------------------

  // repeated .second.protos.ManualStepLearningRate.LearningRateSchedule schedule = 2;
  int schedule_size() const;
  void clear_schedule();
  static const int kScheduleFieldNumber = 2;
  const ::second::protos::ManualStepLearningRate_LearningRateSchedule& schedule(int index) const;
  ::second::protos::ManualStepLearningRate_LearningRateSchedule* mutable_schedule(int index);
  ::second::protos::ManualStepLearningRate_LearningRateSchedule* add_schedule();
  ::google::protobuf::RepeatedPtrField< ::second::protos::ManualStepLearningRate_LearningRateSchedule >*
      mutable_schedule();
  const ::google::protobuf::RepeatedPtrField< ::second::protos::ManualStepLearningRate_LearningRateSchedule >&
      schedule() const;

  // float initial_learning_rate = 1;
  void clear_initial_learning_rate();
  static const int kInitialLearningRateFieldNumber = 1;
  float initial_learning_rate() const;
  void set_initial_learning_rate(float value);

  // @@protoc_insertion_point(class_scope:second.protos.ManualStepLearningRate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::second::protos::ManualStepLearningRate_LearningRateSchedule > schedule_;
  float initial_learning_rate_;
  mutable int _cached_size_;
  friend struct protobuf_second_2fprotos_2foptimizer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CosineDecayLearningRate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:second.protos.CosineDecayLearningRate) */ {
 public:
  CosineDecayLearningRate();
  virtual ~CosineDecayLearningRate();

  CosineDecayLearningRate(const CosineDecayLearningRate& from);

  inline CosineDecayLearningRate& operator=(const CosineDecayLearningRate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CosineDecayLearningRate(CosineDecayLearningRate&& from) noexcept
    : CosineDecayLearningRate() {
    *this = ::std::move(from);
  }

  inline CosineDecayLearningRate& operator=(CosineDecayLearningRate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CosineDecayLearningRate& default_instance();

  static inline const CosineDecayLearningRate* internal_default_instance() {
    return reinterpret_cast<const CosineDecayLearningRate*>(
               &_CosineDecayLearningRate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(CosineDecayLearningRate* other);
  friend void swap(CosineDecayLearningRate& a, CosineDecayLearningRate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CosineDecayLearningRate* New() const PROTOBUF_FINAL { return New(NULL); }

  CosineDecayLearningRate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CosineDecayLearningRate& from);
  void MergeFrom(const CosineDecayLearningRate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CosineDecayLearningRate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float learning_rate_base = 1;
  void clear_learning_rate_base();
  static const int kLearningRateBaseFieldNumber = 1;
  float learning_rate_base() const;
  void set_learning_rate_base(float value);

  // uint32 total_steps = 2;
  void clear_total_steps();
  static const int kTotalStepsFieldNumber = 2;
  ::google::protobuf::uint32 total_steps() const;
  void set_total_steps(::google::protobuf::uint32 value);

  // float warmup_learning_rate = 3;
  void clear_warmup_learning_rate();
  static const int kWarmupLearningRateFieldNumber = 3;
  float warmup_learning_rate() const;
  void set_warmup_learning_rate(float value);

  // uint32 warmup_steps = 4;
  void clear_warmup_steps();
  static const int kWarmupStepsFieldNumber = 4;
  ::google::protobuf::uint32 warmup_steps() const;
  void set_warmup_steps(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:second.protos.CosineDecayLearningRate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float learning_rate_base_;
  ::google::protobuf::uint32 total_steps_;
  float warmup_learning_rate_;
  ::google::protobuf::uint32 warmup_steps_;
  mutable int _cached_size_;
  friend struct protobuf_second_2fprotos_2foptimizer_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Optimizer

// .second.protos.RMSPropOptimizer rms_prop_optimizer = 1;
inline bool Optimizer::has_rms_prop_optimizer() const {
  return optimizer_case() == kRmsPropOptimizer;
}
inline void Optimizer::set_has_rms_prop_optimizer() {
  _oneof_case_[0] = kRmsPropOptimizer;
}
inline void Optimizer::clear_rms_prop_optimizer() {
  if (has_rms_prop_optimizer()) {
    delete optimizer_.rms_prop_optimizer_;
    clear_has_optimizer();
  }
}
inline  const ::second::protos::RMSPropOptimizer& Optimizer::rms_prop_optimizer() const {
  // @@protoc_insertion_point(field_get:second.protos.Optimizer.rms_prop_optimizer)
  return has_rms_prop_optimizer()
      ? *optimizer_.rms_prop_optimizer_
      : ::second::protos::RMSPropOptimizer::default_instance();
}
inline ::second::protos::RMSPropOptimizer* Optimizer::mutable_rms_prop_optimizer() {
  if (!has_rms_prop_optimizer()) {
    clear_optimizer();
    set_has_rms_prop_optimizer();
    optimizer_.rms_prop_optimizer_ = new ::second::protos::RMSPropOptimizer;
  }
  // @@protoc_insertion_point(field_mutable:second.protos.Optimizer.rms_prop_optimizer)
  return optimizer_.rms_prop_optimizer_;
}
inline ::second::protos::RMSPropOptimizer* Optimizer::release_rms_prop_optimizer() {
  // @@protoc_insertion_point(field_release:second.protos.Optimizer.rms_prop_optimizer)
  if (has_rms_prop_optimizer()) {
    clear_has_optimizer();
    ::second::protos::RMSPropOptimizer* temp = optimizer_.rms_prop_optimizer_;
    optimizer_.rms_prop_optimizer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Optimizer::set_allocated_rms_prop_optimizer(::second::protos::RMSPropOptimizer* rms_prop_optimizer) {
  clear_optimizer();
  if (rms_prop_optimizer) {
    set_has_rms_prop_optimizer();
    optimizer_.rms_prop_optimizer_ = rms_prop_optimizer;
  }
  // @@protoc_insertion_point(field_set_allocated:second.protos.Optimizer.rms_prop_optimizer)
}

// .second.protos.MomentumOptimizer momentum_optimizer = 2;
inline bool Optimizer::has_momentum_optimizer() const {
  return optimizer_case() == kMomentumOptimizer;
}
inline void Optimizer::set_has_momentum_optimizer() {
  _oneof_case_[0] = kMomentumOptimizer;
}
inline void Optimizer::clear_momentum_optimizer() {
  if (has_momentum_optimizer()) {
    delete optimizer_.momentum_optimizer_;
    clear_has_optimizer();
  }
}
inline  const ::second::protos::MomentumOptimizer& Optimizer::momentum_optimizer() const {
  // @@protoc_insertion_point(field_get:second.protos.Optimizer.momentum_optimizer)
  return has_momentum_optimizer()
      ? *optimizer_.momentum_optimizer_
      : ::second::protos::MomentumOptimizer::default_instance();
}
inline ::second::protos::MomentumOptimizer* Optimizer::mutable_momentum_optimizer() {
  if (!has_momentum_optimizer()) {
    clear_optimizer();
    set_has_momentum_optimizer();
    optimizer_.momentum_optimizer_ = new ::second::protos::MomentumOptimizer;
  }
  // @@protoc_insertion_point(field_mutable:second.protos.Optimizer.momentum_optimizer)
  return optimizer_.momentum_optimizer_;
}
inline ::second::protos::MomentumOptimizer* Optimizer::release_momentum_optimizer() {
  // @@protoc_insertion_point(field_release:second.protos.Optimizer.momentum_optimizer)
  if (has_momentum_optimizer()) {
    clear_has_optimizer();
    ::second::protos::MomentumOptimizer* temp = optimizer_.momentum_optimizer_;
    optimizer_.momentum_optimizer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Optimizer::set_allocated_momentum_optimizer(::second::protos::MomentumOptimizer* momentum_optimizer) {
  clear_optimizer();
  if (momentum_optimizer) {
    set_has_momentum_optimizer();
    optimizer_.momentum_optimizer_ = momentum_optimizer;
  }
  // @@protoc_insertion_point(field_set_allocated:second.protos.Optimizer.momentum_optimizer)
}

// .second.protos.AdamOptimizer adam_optimizer = 3;
inline bool Optimizer::has_adam_optimizer() const {
  return optimizer_case() == kAdamOptimizer;
}
inline void Optimizer::set_has_adam_optimizer() {
  _oneof_case_[0] = kAdamOptimizer;
}
inline void Optimizer::clear_adam_optimizer() {
  if (has_adam_optimizer()) {
    delete optimizer_.adam_optimizer_;
    clear_has_optimizer();
  }
}
inline  const ::second::protos::AdamOptimizer& Optimizer::adam_optimizer() const {
  // @@protoc_insertion_point(field_get:second.protos.Optimizer.adam_optimizer)
  return has_adam_optimizer()
      ? *optimizer_.adam_optimizer_
      : ::second::protos::AdamOptimizer::default_instance();
}
inline ::second::protos::AdamOptimizer* Optimizer::mutable_adam_optimizer() {
  if (!has_adam_optimizer()) {
    clear_optimizer();
    set_has_adam_optimizer();
    optimizer_.adam_optimizer_ = new ::second::protos::AdamOptimizer;
  }
  // @@protoc_insertion_point(field_mutable:second.protos.Optimizer.adam_optimizer)
  return optimizer_.adam_optimizer_;
}
inline ::second::protos::AdamOptimizer* Optimizer::release_adam_optimizer() {
  // @@protoc_insertion_point(field_release:second.protos.Optimizer.adam_optimizer)
  if (has_adam_optimizer()) {
    clear_has_optimizer();
    ::second::protos::AdamOptimizer* temp = optimizer_.adam_optimizer_;
    optimizer_.adam_optimizer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Optimizer::set_allocated_adam_optimizer(::second::protos::AdamOptimizer* adam_optimizer) {
  clear_optimizer();
  if (adam_optimizer) {
    set_has_adam_optimizer();
    optimizer_.adam_optimizer_ = adam_optimizer;
  }
  // @@protoc_insertion_point(field_set_allocated:second.protos.Optimizer.adam_optimizer)
}

// bool use_moving_average = 4;
inline void Optimizer::clear_use_moving_average() {
  use_moving_average_ = false;
}
inline bool Optimizer::use_moving_average() const {
  // @@protoc_insertion_point(field_get:second.protos.Optimizer.use_moving_average)
  return use_moving_average_;
}
inline void Optimizer::set_use_moving_average(bool value) {
  
  use_moving_average_ = value;
  // @@protoc_insertion_point(field_set:second.protos.Optimizer.use_moving_average)
}

// float moving_average_decay = 5;
inline void Optimizer::clear_moving_average_decay() {
  moving_average_decay_ = 0;
}
inline float Optimizer::moving_average_decay() const {
  // @@protoc_insertion_point(field_get:second.protos.Optimizer.moving_average_decay)
  return moving_average_decay_;
}
inline void Optimizer::set_moving_average_decay(float value) {
  
  moving_average_decay_ = value;
  // @@protoc_insertion_point(field_set:second.protos.Optimizer.moving_average_decay)
}

inline bool Optimizer::has_optimizer() const {
  return optimizer_case() != OPTIMIZER_NOT_SET;
}
inline void Optimizer::clear_has_optimizer() {
  _oneof_case_[0] = OPTIMIZER_NOT_SET;
}
inline Optimizer::OptimizerCase Optimizer::optimizer_case() const {
  return Optimizer::OptimizerCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RMSPropOptimizer

// .second.protos.LearningRate learning_rate = 1;
inline bool RMSPropOptimizer::has_learning_rate() const {
  return this != internal_default_instance() && learning_rate_ != NULL;
}
inline void RMSPropOptimizer::clear_learning_rate() {
  if (GetArenaNoVirtual() == NULL && learning_rate_ != NULL) delete learning_rate_;
  learning_rate_ = NULL;
}
inline const ::second::protos::LearningRate& RMSPropOptimizer::learning_rate() const {
  const ::second::protos::LearningRate* p = learning_rate_;
  // @@protoc_insertion_point(field_get:second.protos.RMSPropOptimizer.learning_rate)
  return p != NULL ? *p : *reinterpret_cast<const ::second::protos::LearningRate*>(
      &::second::protos::_LearningRate_default_instance_);
}
inline ::second::protos::LearningRate* RMSPropOptimizer::mutable_learning_rate() {
  
  if (learning_rate_ == NULL) {
    learning_rate_ = new ::second::protos::LearningRate;
  }
  // @@protoc_insertion_point(field_mutable:second.protos.RMSPropOptimizer.learning_rate)
  return learning_rate_;
}
inline ::second::protos::LearningRate* RMSPropOptimizer::release_learning_rate() {
  // @@protoc_insertion_point(field_release:second.protos.RMSPropOptimizer.learning_rate)
  
  ::second::protos::LearningRate* temp = learning_rate_;
  learning_rate_ = NULL;
  return temp;
}
inline void RMSPropOptimizer::set_allocated_learning_rate(::second::protos::LearningRate* learning_rate) {
  delete learning_rate_;
  learning_rate_ = learning_rate;
  if (learning_rate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:second.protos.RMSPropOptimizer.learning_rate)
}

// float momentum_optimizer_value = 2;
inline void RMSPropOptimizer::clear_momentum_optimizer_value() {
  momentum_optimizer_value_ = 0;
}
inline float RMSPropOptimizer::momentum_optimizer_value() const {
  // @@protoc_insertion_point(field_get:second.protos.RMSPropOptimizer.momentum_optimizer_value)
  return momentum_optimizer_value_;
}
inline void RMSPropOptimizer::set_momentum_optimizer_value(float value) {
  
  momentum_optimizer_value_ = value;
  // @@protoc_insertion_point(field_set:second.protos.RMSPropOptimizer.momentum_optimizer_value)
}

// float decay = 3;
inline void RMSPropOptimizer::clear_decay() {
  decay_ = 0;
}
inline float RMSPropOptimizer::decay() const {
  // @@protoc_insertion_point(field_get:second.protos.RMSPropOptimizer.decay)
  return decay_;
}
inline void RMSPropOptimizer::set_decay(float value) {
  
  decay_ = value;
  // @@protoc_insertion_point(field_set:second.protos.RMSPropOptimizer.decay)
}

// float epsilon = 4;
inline void RMSPropOptimizer::clear_epsilon() {
  epsilon_ = 0;
}
inline float RMSPropOptimizer::epsilon() const {
  // @@protoc_insertion_point(field_get:second.protos.RMSPropOptimizer.epsilon)
  return epsilon_;
}
inline void RMSPropOptimizer::set_epsilon(float value) {
  
  epsilon_ = value;
  // @@protoc_insertion_point(field_set:second.protos.RMSPropOptimizer.epsilon)
}

// float weight_decay = 5;
inline void RMSPropOptimizer::clear_weight_decay() {
  weight_decay_ = 0;
}
inline float RMSPropOptimizer::weight_decay() const {
  // @@protoc_insertion_point(field_get:second.protos.RMSPropOptimizer.weight_decay)
  return weight_decay_;
}
inline void RMSPropOptimizer::set_weight_decay(float value) {
  
  weight_decay_ = value;
  // @@protoc_insertion_point(field_set:second.protos.RMSPropOptimizer.weight_decay)
}

// -------------------------------------------------------------------

// MomentumOptimizer

// .second.protos.LearningRate learning_rate = 1;
inline bool MomentumOptimizer::has_learning_rate() const {
  return this != internal_default_instance() && learning_rate_ != NULL;
}
inline void MomentumOptimizer::clear_learning_rate() {
  if (GetArenaNoVirtual() == NULL && learning_rate_ != NULL) delete learning_rate_;
  learning_rate_ = NULL;
}
inline const ::second::protos::LearningRate& MomentumOptimizer::learning_rate() const {
  const ::second::protos::LearningRate* p = learning_rate_;
  // @@protoc_insertion_point(field_get:second.protos.MomentumOptimizer.learning_rate)
  return p != NULL ? *p : *reinterpret_cast<const ::second::protos::LearningRate*>(
      &::second::protos::_LearningRate_default_instance_);
}
inline ::second::protos::LearningRate* MomentumOptimizer::mutable_learning_rate() {
  
  if (learning_rate_ == NULL) {
    learning_rate_ = new ::second::protos::LearningRate;
  }
  // @@protoc_insertion_point(field_mutable:second.protos.MomentumOptimizer.learning_rate)
  return learning_rate_;
}
inline ::second::protos::LearningRate* MomentumOptimizer::release_learning_rate() {
  // @@protoc_insertion_point(field_release:second.protos.MomentumOptimizer.learning_rate)
  
  ::second::protos::LearningRate* temp = learning_rate_;
  learning_rate_ = NULL;
  return temp;
}
inline void MomentumOptimizer::set_allocated_learning_rate(::second::protos::LearningRate* learning_rate) {
  delete learning_rate_;
  learning_rate_ = learning_rate;
  if (learning_rate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:second.protos.MomentumOptimizer.learning_rate)
}

// float momentum_optimizer_value = 2;
inline void MomentumOptimizer::clear_momentum_optimizer_value() {
  momentum_optimizer_value_ = 0;
}
inline float MomentumOptimizer::momentum_optimizer_value() const {
  // @@protoc_insertion_point(field_get:second.protos.MomentumOptimizer.momentum_optimizer_value)
  return momentum_optimizer_value_;
}
inline void MomentumOptimizer::set_momentum_optimizer_value(float value) {
  
  momentum_optimizer_value_ = value;
  // @@protoc_insertion_point(field_set:second.protos.MomentumOptimizer.momentum_optimizer_value)
}

// float weight_decay = 3;
inline void MomentumOptimizer::clear_weight_decay() {
  weight_decay_ = 0;
}
inline float MomentumOptimizer::weight_decay() const {
  // @@protoc_insertion_point(field_get:second.protos.MomentumOptimizer.weight_decay)
  return weight_decay_;
}
inline void MomentumOptimizer::set_weight_decay(float value) {
  
  weight_decay_ = value;
  // @@protoc_insertion_point(field_set:second.protos.MomentumOptimizer.weight_decay)
}

// -------------------------------------------------------------------

// AdamOptimizer

// .second.protos.LearningRate learning_rate = 1;
inline bool AdamOptimizer::has_learning_rate() const {
  return this != internal_default_instance() && learning_rate_ != NULL;
}
inline void AdamOptimizer::clear_learning_rate() {
  if (GetArenaNoVirtual() == NULL && learning_rate_ != NULL) delete learning_rate_;
  learning_rate_ = NULL;
}
inline const ::second::protos::LearningRate& AdamOptimizer::learning_rate() const {
  const ::second::protos::LearningRate* p = learning_rate_;
  // @@protoc_insertion_point(field_get:second.protos.AdamOptimizer.learning_rate)
  return p != NULL ? *p : *reinterpret_cast<const ::second::protos::LearningRate*>(
      &::second::protos::_LearningRate_default_instance_);
}
inline ::second::protos::LearningRate* AdamOptimizer::mutable_learning_rate() {
  
  if (learning_rate_ == NULL) {
    learning_rate_ = new ::second::protos::LearningRate;
  }
  // @@protoc_insertion_point(field_mutable:second.protos.AdamOptimizer.learning_rate)
  return learning_rate_;
}
inline ::second::protos::LearningRate* AdamOptimizer::release_learning_rate() {
  // @@protoc_insertion_point(field_release:second.protos.AdamOptimizer.learning_rate)
  
  ::second::protos::LearningRate* temp = learning_rate_;
  learning_rate_ = NULL;
  return temp;
}
inline void AdamOptimizer::set_allocated_learning_rate(::second::protos::LearningRate* learning_rate) {
  delete learning_rate_;
  learning_rate_ = learning_rate;
  if (learning_rate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:second.protos.AdamOptimizer.learning_rate)
}

// float weight_decay = 2;
inline void AdamOptimizer::clear_weight_decay() {
  weight_decay_ = 0;
}
inline float AdamOptimizer::weight_decay() const {
  // @@protoc_insertion_point(field_get:second.protos.AdamOptimizer.weight_decay)
  return weight_decay_;
}
inline void AdamOptimizer::set_weight_decay(float value) {
  
  weight_decay_ = value;
  // @@protoc_insertion_point(field_set:second.protos.AdamOptimizer.weight_decay)
}

// -------------------------------------------------------------------

// LearningRate

// .second.protos.ConstantLearningRate constant_learning_rate = 1;
inline bool LearningRate::has_constant_learning_rate() const {
  return learning_rate_case() == kConstantLearningRate;
}
inline void LearningRate::set_has_constant_learning_rate() {
  _oneof_case_[0] = kConstantLearningRate;
}
inline void LearningRate::clear_constant_learning_rate() {
  if (has_constant_learning_rate()) {
    delete learning_rate_.constant_learning_rate_;
    clear_has_learning_rate();
  }
}
inline  const ::second::protos::ConstantLearningRate& LearningRate::constant_learning_rate() const {
  // @@protoc_insertion_point(field_get:second.protos.LearningRate.constant_learning_rate)
  return has_constant_learning_rate()
      ? *learning_rate_.constant_learning_rate_
      : ::second::protos::ConstantLearningRate::default_instance();
}
inline ::second::protos::ConstantLearningRate* LearningRate::mutable_constant_learning_rate() {
  if (!has_constant_learning_rate()) {
    clear_learning_rate();
    set_has_constant_learning_rate();
    learning_rate_.constant_learning_rate_ = new ::second::protos::ConstantLearningRate;
  }
  // @@protoc_insertion_point(field_mutable:second.protos.LearningRate.constant_learning_rate)
  return learning_rate_.constant_learning_rate_;
}
inline ::second::protos::ConstantLearningRate* LearningRate::release_constant_learning_rate() {
  // @@protoc_insertion_point(field_release:second.protos.LearningRate.constant_learning_rate)
  if (has_constant_learning_rate()) {
    clear_has_learning_rate();
    ::second::protos::ConstantLearningRate* temp = learning_rate_.constant_learning_rate_;
    learning_rate_.constant_learning_rate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LearningRate::set_allocated_constant_learning_rate(::second::protos::ConstantLearningRate* constant_learning_rate) {
  clear_learning_rate();
  if (constant_learning_rate) {
    set_has_constant_learning_rate();
    learning_rate_.constant_learning_rate_ = constant_learning_rate;
  }
  // @@protoc_insertion_point(field_set_allocated:second.protos.LearningRate.constant_learning_rate)
}

// .second.protos.ExponentialDecayLearningRate exponential_decay_learning_rate = 2;
inline bool LearningRate::has_exponential_decay_learning_rate() const {
  return learning_rate_case() == kExponentialDecayLearningRate;
}
inline void LearningRate::set_has_exponential_decay_learning_rate() {
  _oneof_case_[0] = kExponentialDecayLearningRate;
}
inline void LearningRate::clear_exponential_decay_learning_rate() {
  if (has_exponential_decay_learning_rate()) {
    delete learning_rate_.exponential_decay_learning_rate_;
    clear_has_learning_rate();
  }
}
inline  const ::second::protos::ExponentialDecayLearningRate& LearningRate::exponential_decay_learning_rate() const {
  // @@protoc_insertion_point(field_get:second.protos.LearningRate.exponential_decay_learning_rate)
  return has_exponential_decay_learning_rate()
      ? *learning_rate_.exponential_decay_learning_rate_
      : ::second::protos::ExponentialDecayLearningRate::default_instance();
}
inline ::second::protos::ExponentialDecayLearningRate* LearningRate::mutable_exponential_decay_learning_rate() {
  if (!has_exponential_decay_learning_rate()) {
    clear_learning_rate();
    set_has_exponential_decay_learning_rate();
    learning_rate_.exponential_decay_learning_rate_ = new ::second::protos::ExponentialDecayLearningRate;
  }
  // @@protoc_insertion_point(field_mutable:second.protos.LearningRate.exponential_decay_learning_rate)
  return learning_rate_.exponential_decay_learning_rate_;
}
inline ::second::protos::ExponentialDecayLearningRate* LearningRate::release_exponential_decay_learning_rate() {
  // @@protoc_insertion_point(field_release:second.protos.LearningRate.exponential_decay_learning_rate)
  if (has_exponential_decay_learning_rate()) {
    clear_has_learning_rate();
    ::second::protos::ExponentialDecayLearningRate* temp = learning_rate_.exponential_decay_learning_rate_;
    learning_rate_.exponential_decay_learning_rate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LearningRate::set_allocated_exponential_decay_learning_rate(::second::protos::ExponentialDecayLearningRate* exponential_decay_learning_rate) {
  clear_learning_rate();
  if (exponential_decay_learning_rate) {
    set_has_exponential_decay_learning_rate();
    learning_rate_.exponential_decay_learning_rate_ = exponential_decay_learning_rate;
  }
  // @@protoc_insertion_point(field_set_allocated:second.protos.LearningRate.exponential_decay_learning_rate)
}

// .second.protos.ManualStepLearningRate manual_step_learning_rate = 3;
inline bool LearningRate::has_manual_step_learning_rate() const {
  return learning_rate_case() == kManualStepLearningRate;
}
inline void LearningRate::set_has_manual_step_learning_rate() {
  _oneof_case_[0] = kManualStepLearningRate;
}
inline void LearningRate::clear_manual_step_learning_rate() {
  if (has_manual_step_learning_rate()) {
    delete learning_rate_.manual_step_learning_rate_;
    clear_has_learning_rate();
  }
}
inline  const ::second::protos::ManualStepLearningRate& LearningRate::manual_step_learning_rate() const {
  // @@protoc_insertion_point(field_get:second.protos.LearningRate.manual_step_learning_rate)
  return has_manual_step_learning_rate()
      ? *learning_rate_.manual_step_learning_rate_
      : ::second::protos::ManualStepLearningRate::default_instance();
}
inline ::second::protos::ManualStepLearningRate* LearningRate::mutable_manual_step_learning_rate() {
  if (!has_manual_step_learning_rate()) {
    clear_learning_rate();
    set_has_manual_step_learning_rate();
    learning_rate_.manual_step_learning_rate_ = new ::second::protos::ManualStepLearningRate;
  }
  // @@protoc_insertion_point(field_mutable:second.protos.LearningRate.manual_step_learning_rate)
  return learning_rate_.manual_step_learning_rate_;
}
inline ::second::protos::ManualStepLearningRate* LearningRate::release_manual_step_learning_rate() {
  // @@protoc_insertion_point(field_release:second.protos.LearningRate.manual_step_learning_rate)
  if (has_manual_step_learning_rate()) {
    clear_has_learning_rate();
    ::second::protos::ManualStepLearningRate* temp = learning_rate_.manual_step_learning_rate_;
    learning_rate_.manual_step_learning_rate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LearningRate::set_allocated_manual_step_learning_rate(::second::protos::ManualStepLearningRate* manual_step_learning_rate) {
  clear_learning_rate();
  if (manual_step_learning_rate) {
    set_has_manual_step_learning_rate();
    learning_rate_.manual_step_learning_rate_ = manual_step_learning_rate;
  }
  // @@protoc_insertion_point(field_set_allocated:second.protos.LearningRate.manual_step_learning_rate)
}

// .second.protos.CosineDecayLearningRate cosine_decay_learning_rate = 4;
inline bool LearningRate::has_cosine_decay_learning_rate() const {
  return learning_rate_case() == kCosineDecayLearningRate;
}
inline void LearningRate::set_has_cosine_decay_learning_rate() {
  _oneof_case_[0] = kCosineDecayLearningRate;
}
inline void LearningRate::clear_cosine_decay_learning_rate() {
  if (has_cosine_decay_learning_rate()) {
    delete learning_rate_.cosine_decay_learning_rate_;
    clear_has_learning_rate();
  }
}
inline  const ::second::protos::CosineDecayLearningRate& LearningRate::cosine_decay_learning_rate() const {
  // @@protoc_insertion_point(field_get:second.protos.LearningRate.cosine_decay_learning_rate)
  return has_cosine_decay_learning_rate()
      ? *learning_rate_.cosine_decay_learning_rate_
      : ::second::protos::CosineDecayLearningRate::default_instance();
}
inline ::second::protos::CosineDecayLearningRate* LearningRate::mutable_cosine_decay_learning_rate() {
  if (!has_cosine_decay_learning_rate()) {
    clear_learning_rate();
    set_has_cosine_decay_learning_rate();
    learning_rate_.cosine_decay_learning_rate_ = new ::second::protos::CosineDecayLearningRate;
  }
  // @@protoc_insertion_point(field_mutable:second.protos.LearningRate.cosine_decay_learning_rate)
  return learning_rate_.cosine_decay_learning_rate_;
}
inline ::second::protos::CosineDecayLearningRate* LearningRate::release_cosine_decay_learning_rate() {
  // @@protoc_insertion_point(field_release:second.protos.LearningRate.cosine_decay_learning_rate)
  if (has_cosine_decay_learning_rate()) {
    clear_has_learning_rate();
    ::second::protos::CosineDecayLearningRate* temp = learning_rate_.cosine_decay_learning_rate_;
    learning_rate_.cosine_decay_learning_rate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LearningRate::set_allocated_cosine_decay_learning_rate(::second::protos::CosineDecayLearningRate* cosine_decay_learning_rate) {
  clear_learning_rate();
  if (cosine_decay_learning_rate) {
    set_has_cosine_decay_learning_rate();
    learning_rate_.cosine_decay_learning_rate_ = cosine_decay_learning_rate;
  }
  // @@protoc_insertion_point(field_set_allocated:second.protos.LearningRate.cosine_decay_learning_rate)
}

inline bool LearningRate::has_learning_rate() const {
  return learning_rate_case() != LEARNING_RATE_NOT_SET;
}
inline void LearningRate::clear_has_learning_rate() {
  _oneof_case_[0] = LEARNING_RATE_NOT_SET;
}
inline LearningRate::LearningRateCase LearningRate::learning_rate_case() const {
  return LearningRate::LearningRateCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConstantLearningRate

// float learning_rate = 1;
inline void ConstantLearningRate::clear_learning_rate() {
  learning_rate_ = 0;
}
inline float ConstantLearningRate::learning_rate() const {
  // @@protoc_insertion_point(field_get:second.protos.ConstantLearningRate.learning_rate)
  return learning_rate_;
}
inline void ConstantLearningRate::set_learning_rate(float value) {
  
  learning_rate_ = value;
  // @@protoc_insertion_point(field_set:second.protos.ConstantLearningRate.learning_rate)
}

// -------------------------------------------------------------------

// ExponentialDecayLearningRate

// float initial_learning_rate = 1;
inline void ExponentialDecayLearningRate::clear_initial_learning_rate() {
  initial_learning_rate_ = 0;
}
inline float ExponentialDecayLearningRate::initial_learning_rate() const {
  // @@protoc_insertion_point(field_get:second.protos.ExponentialDecayLearningRate.initial_learning_rate)
  return initial_learning_rate_;
}
inline void ExponentialDecayLearningRate::set_initial_learning_rate(float value) {
  
  initial_learning_rate_ = value;
  // @@protoc_insertion_point(field_set:second.protos.ExponentialDecayLearningRate.initial_learning_rate)
}

// uint32 decay_steps = 2;
inline void ExponentialDecayLearningRate::clear_decay_steps() {
  decay_steps_ = 0u;
}
inline ::google::protobuf::uint32 ExponentialDecayLearningRate::decay_steps() const {
  // @@protoc_insertion_point(field_get:second.protos.ExponentialDecayLearningRate.decay_steps)
  return decay_steps_;
}
inline void ExponentialDecayLearningRate::set_decay_steps(::google::protobuf::uint32 value) {
  
  decay_steps_ = value;
  // @@protoc_insertion_point(field_set:second.protos.ExponentialDecayLearningRate.decay_steps)
}

// float decay_factor = 3;
inline void ExponentialDecayLearningRate::clear_decay_factor() {
  decay_factor_ = 0;
}
inline float ExponentialDecayLearningRate::decay_factor() const {
  // @@protoc_insertion_point(field_get:second.protos.ExponentialDecayLearningRate.decay_factor)
  return decay_factor_;
}
inline void ExponentialDecayLearningRate::set_decay_factor(float value) {
  
  decay_factor_ = value;
  // @@protoc_insertion_point(field_set:second.protos.ExponentialDecayLearningRate.decay_factor)
}

// bool staircase = 4;
inline void ExponentialDecayLearningRate::clear_staircase() {
  staircase_ = false;
}
inline bool ExponentialDecayLearningRate::staircase() const {
  // @@protoc_insertion_point(field_get:second.protos.ExponentialDecayLearningRate.staircase)
  return staircase_;
}
inline void ExponentialDecayLearningRate::set_staircase(bool value) {
  
  staircase_ = value;
  // @@protoc_insertion_point(field_set:second.protos.ExponentialDecayLearningRate.staircase)
}

// -------------------------------------------------------------------

// ManualStepLearningRate_LearningRateSchedule

// uint32 step = 1;
inline void ManualStepLearningRate_LearningRateSchedule::clear_step() {
  step_ = 0u;
}
inline ::google::protobuf::uint32 ManualStepLearningRate_LearningRateSchedule::step() const {
  // @@protoc_insertion_point(field_get:second.protos.ManualStepLearningRate.LearningRateSchedule.step)
  return step_;
}
inline void ManualStepLearningRate_LearningRateSchedule::set_step(::google::protobuf::uint32 value) {
  
  step_ = value;
  // @@protoc_insertion_point(field_set:second.protos.ManualStepLearningRate.LearningRateSchedule.step)
}

// float learning_rate = 2;
inline void ManualStepLearningRate_LearningRateSchedule::clear_learning_rate() {
  learning_rate_ = 0;
}
inline float ManualStepLearningRate_LearningRateSchedule::learning_rate() const {
  // @@protoc_insertion_point(field_get:second.protos.ManualStepLearningRate.LearningRateSchedule.learning_rate)
  return learning_rate_;
}
inline void ManualStepLearningRate_LearningRateSchedule::set_learning_rate(float value) {
  
  learning_rate_ = value;
  // @@protoc_insertion_point(field_set:second.protos.ManualStepLearningRate.LearningRateSchedule.learning_rate)
}

// -------------------------------------------------------------------

// ManualStepLearningRate

// float initial_learning_rate = 1;
inline void ManualStepLearningRate::clear_initial_learning_rate() {
  initial_learning_rate_ = 0;
}
inline float ManualStepLearningRate::initial_learning_rate() const {
  // @@protoc_insertion_point(field_get:second.protos.ManualStepLearningRate.initial_learning_rate)
  return initial_learning_rate_;
}
inline void ManualStepLearningRate::set_initial_learning_rate(float value) {
  
  initial_learning_rate_ = value;
  // @@protoc_insertion_point(field_set:second.protos.ManualStepLearningRate.initial_learning_rate)
}

// repeated .second.protos.ManualStepLearningRate.LearningRateSchedule schedule = 2;
inline int ManualStepLearningRate::schedule_size() const {
  return schedule_.size();
}
inline void ManualStepLearningRate::clear_schedule() {
  schedule_.Clear();
}
inline const ::second::protos::ManualStepLearningRate_LearningRateSchedule& ManualStepLearningRate::schedule(int index) const {
  // @@protoc_insertion_point(field_get:second.protos.ManualStepLearningRate.schedule)
  return schedule_.Get(index);
}
inline ::second::protos::ManualStepLearningRate_LearningRateSchedule* ManualStepLearningRate::mutable_schedule(int index) {
  // @@protoc_insertion_point(field_mutable:second.protos.ManualStepLearningRate.schedule)
  return schedule_.Mutable(index);
}
inline ::second::protos::ManualStepLearningRate_LearningRateSchedule* ManualStepLearningRate::add_schedule() {
  // @@protoc_insertion_point(field_add:second.protos.ManualStepLearningRate.schedule)
  return schedule_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::second::protos::ManualStepLearningRate_LearningRateSchedule >*
ManualStepLearningRate::mutable_schedule() {
  // @@protoc_insertion_point(field_mutable_list:second.protos.ManualStepLearningRate.schedule)
  return &schedule_;
}
inline const ::google::protobuf::RepeatedPtrField< ::second::protos::ManualStepLearningRate_LearningRateSchedule >&
ManualStepLearningRate::schedule() const {
  // @@protoc_insertion_point(field_list:second.protos.ManualStepLearningRate.schedule)
  return schedule_;
}

// -------------------------------------------------------------------

// CosineDecayLearningRate

// float learning_rate_base = 1;
inline void CosineDecayLearningRate::clear_learning_rate_base() {
  learning_rate_base_ = 0;
}
inline float CosineDecayLearningRate::learning_rate_base() const {
  // @@protoc_insertion_point(field_get:second.protos.CosineDecayLearningRate.learning_rate_base)
  return learning_rate_base_;
}
inline void CosineDecayLearningRate::set_learning_rate_base(float value) {
  
  learning_rate_base_ = value;
  // @@protoc_insertion_point(field_set:second.protos.CosineDecayLearningRate.learning_rate_base)
}

// uint32 total_steps = 2;
inline void CosineDecayLearningRate::clear_total_steps() {
  total_steps_ = 0u;
}
inline ::google::protobuf::uint32 CosineDecayLearningRate::total_steps() const {
  // @@protoc_insertion_point(field_get:second.protos.CosineDecayLearningRate.total_steps)
  return total_steps_;
}
inline void CosineDecayLearningRate::set_total_steps(::google::protobuf::uint32 value) {
  
  total_steps_ = value;
  // @@protoc_insertion_point(field_set:second.protos.CosineDecayLearningRate.total_steps)
}

// float warmup_learning_rate = 3;
inline void CosineDecayLearningRate::clear_warmup_learning_rate() {
  warmup_learning_rate_ = 0;
}
inline float CosineDecayLearningRate::warmup_learning_rate() const {
  // @@protoc_insertion_point(field_get:second.protos.CosineDecayLearningRate.warmup_learning_rate)
  return warmup_learning_rate_;
}
inline void CosineDecayLearningRate::set_warmup_learning_rate(float value) {
  
  warmup_learning_rate_ = value;
  // @@protoc_insertion_point(field_set:second.protos.CosineDecayLearningRate.warmup_learning_rate)
}

// uint32 warmup_steps = 4;
inline void CosineDecayLearningRate::clear_warmup_steps() {
  warmup_steps_ = 0u;
}
inline ::google::protobuf::uint32 CosineDecayLearningRate::warmup_steps() const {
  // @@protoc_insertion_point(field_get:second.protos.CosineDecayLearningRate.warmup_steps)
  return warmup_steps_;
}
inline void CosineDecayLearningRate::set_warmup_steps(::google::protobuf::uint32 value) {
  
  warmup_steps_ = value;
  // @@protoc_insertion_point(field_set:second.protos.CosineDecayLearningRate.warmup_steps)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace protos
}  // namespace second

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_second_2fprotos_2foptimizer_2eproto__INCLUDED
