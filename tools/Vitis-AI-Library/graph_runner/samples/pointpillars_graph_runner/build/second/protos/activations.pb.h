// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: second/protos/activations.proto

#ifndef PROTOBUF_second_2fprotos_2factivations_2eproto__INCLUDED
#define PROTOBUF_second_2fprotos_2factivations_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace second {
namespace protos {
class Activation;
class ActivationDefaultTypeInternal;
extern ActivationDefaultTypeInternal _Activation_default_instance_;
class ELU;
class ELUDefaultTypeInternal;
extern ELUDefaultTypeInternal _ELU_default_instance_;
class LeakyReLU;
class LeakyReLUDefaultTypeInternal;
extern LeakyReLUDefaultTypeInternal _LeakyReLU_default_instance_;
class ReLU;
class ReLUDefaultTypeInternal;
extern ReLUDefaultTypeInternal _ReLU_default_instance_;
class ReLU6;
class ReLU6DefaultTypeInternal;
extern ReLU6DefaultTypeInternal _ReLU6_default_instance_;
class SELU;
class SELUDefaultTypeInternal;
extern SELUDefaultTypeInternal _SELU_default_instance_;
class Softplus;
class SoftplusDefaultTypeInternal;
extern SoftplusDefaultTypeInternal _Softplus_default_instance_;
class Softsign;
class SoftsignDefaultTypeInternal;
extern SoftsignDefaultTypeInternal _Softsign_default_instance_;
class Swish;
class SwishDefaultTypeInternal;
extern SwishDefaultTypeInternal _Swish_default_instance_;
}  // namespace protos
}  // namespace second

namespace second {
namespace protos {

namespace protobuf_second_2fprotos_2factivations_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_second_2fprotos_2factivations_2eproto

// ===================================================================

class ReLU : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:second.protos.ReLU) */ {
 public:
  ReLU();
  virtual ~ReLU();

  ReLU(const ReLU& from);

  inline ReLU& operator=(const ReLU& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReLU(ReLU&& from) noexcept
    : ReLU() {
    *this = ::std::move(from);
  }

  inline ReLU& operator=(ReLU&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReLU& default_instance();

  static inline const ReLU* internal_default_instance() {
    return reinterpret_cast<const ReLU*>(
               &_ReLU_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ReLU* other);
  friend void swap(ReLU& a, ReLU& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReLU* New() const PROTOBUF_FINAL { return New(NULL); }

  ReLU* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReLU& from);
  void MergeFrom(const ReLU& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReLU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:second.protos.ReLU)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_second_2fprotos_2factivations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LeakyReLU : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:second.protos.LeakyReLU) */ {
 public:
  LeakyReLU();
  virtual ~LeakyReLU();

  LeakyReLU(const LeakyReLU& from);

  inline LeakyReLU& operator=(const LeakyReLU& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LeakyReLU(LeakyReLU&& from) noexcept
    : LeakyReLU() {
    *this = ::std::move(from);
  }

  inline LeakyReLU& operator=(LeakyReLU&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeakyReLU& default_instance();

  static inline const LeakyReLU* internal_default_instance() {
    return reinterpret_cast<const LeakyReLU*>(
               &_LeakyReLU_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(LeakyReLU* other);
  friend void swap(LeakyReLU& a, LeakyReLU& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LeakyReLU* New() const PROTOBUF_FINAL { return New(NULL); }

  LeakyReLU* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LeakyReLU& from);
  void MergeFrom(const LeakyReLU& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LeakyReLU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float leakness = 1;
  void clear_leakness();
  static const int kLeaknessFieldNumber = 1;
  float leakness() const;
  void set_leakness(float value);

  // @@protoc_insertion_point(class_scope:second.protos.LeakyReLU)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float leakness_;
  mutable int _cached_size_;
  friend struct protobuf_second_2fprotos_2factivations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Swish : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:second.protos.Swish) */ {
 public:
  Swish();
  virtual ~Swish();

  Swish(const Swish& from);

  inline Swish& operator=(const Swish& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Swish(Swish&& from) noexcept
    : Swish() {
    *this = ::std::move(from);
  }

  inline Swish& operator=(Swish&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Swish& default_instance();

  static inline const Swish* internal_default_instance() {
    return reinterpret_cast<const Swish*>(
               &_Swish_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Swish* other);
  friend void swap(Swish& a, Swish& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Swish* New() const PROTOBUF_FINAL { return New(NULL); }

  Swish* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Swish& from);
  void MergeFrom(const Swish& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Swish* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:second.protos.Swish)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_second_2fprotos_2factivations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ELU : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:second.protos.ELU) */ {
 public:
  ELU();
  virtual ~ELU();

  ELU(const ELU& from);

  inline ELU& operator=(const ELU& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ELU(ELU&& from) noexcept
    : ELU() {
    *this = ::std::move(from);
  }

  inline ELU& operator=(ELU&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ELU& default_instance();

  static inline const ELU* internal_default_instance() {
    return reinterpret_cast<const ELU*>(
               &_ELU_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ELU* other);
  friend void swap(ELU& a, ELU& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ELU* New() const PROTOBUF_FINAL { return New(NULL); }

  ELU* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ELU& from);
  void MergeFrom(const ELU& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ELU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float alpha = 1;
  void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  float alpha() const;
  void set_alpha(float value);

  // @@protoc_insertion_point(class_scope:second.protos.ELU)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float alpha_;
  mutable int _cached_size_;
  friend struct protobuf_second_2fprotos_2factivations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Softplus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:second.protos.Softplus) */ {
 public:
  Softplus();
  virtual ~Softplus();

  Softplus(const Softplus& from);

  inline Softplus& operator=(const Softplus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Softplus(Softplus&& from) noexcept
    : Softplus() {
    *this = ::std::move(from);
  }

  inline Softplus& operator=(Softplus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Softplus& default_instance();

  static inline const Softplus* internal_default_instance() {
    return reinterpret_cast<const Softplus*>(
               &_Softplus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Softplus* other);
  friend void swap(Softplus& a, Softplus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Softplus* New() const PROTOBUF_FINAL { return New(NULL); }

  Softplus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Softplus& from);
  void MergeFrom(const Softplus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Softplus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float beta = 1;
  void clear_beta();
  static const int kBetaFieldNumber = 1;
  float beta() const;
  void set_beta(float value);

  // float threshold = 2;
  void clear_threshold();
  static const int kThresholdFieldNumber = 2;
  float threshold() const;
  void set_threshold(float value);

  // @@protoc_insertion_point(class_scope:second.protos.Softplus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float beta_;
  float threshold_;
  mutable int _cached_size_;
  friend struct protobuf_second_2fprotos_2factivations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Softsign : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:second.protos.Softsign) */ {
 public:
  Softsign();
  virtual ~Softsign();

  Softsign(const Softsign& from);

  inline Softsign& operator=(const Softsign& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Softsign(Softsign&& from) noexcept
    : Softsign() {
    *this = ::std::move(from);
  }

  inline Softsign& operator=(Softsign&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Softsign& default_instance();

  static inline const Softsign* internal_default_instance() {
    return reinterpret_cast<const Softsign*>(
               &_Softsign_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Softsign* other);
  friend void swap(Softsign& a, Softsign& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Softsign* New() const PROTOBUF_FINAL { return New(NULL); }

  Softsign* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Softsign& from);
  void MergeFrom(const Softsign& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Softsign* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:second.protos.Softsign)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_second_2fprotos_2factivations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReLU6 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:second.protos.ReLU6) */ {
 public:
  ReLU6();
  virtual ~ReLU6();

  ReLU6(const ReLU6& from);

  inline ReLU6& operator=(const ReLU6& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReLU6(ReLU6&& from) noexcept
    : ReLU6() {
    *this = ::std::move(from);
  }

  inline ReLU6& operator=(ReLU6&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReLU6& default_instance();

  static inline const ReLU6* internal_default_instance() {
    return reinterpret_cast<const ReLU6*>(
               &_ReLU6_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ReLU6* other);
  friend void swap(ReLU6& a, ReLU6& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReLU6* New() const PROTOBUF_FINAL { return New(NULL); }

  ReLU6* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReLU6& from);
  void MergeFrom(const ReLU6& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReLU6* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:second.protos.ReLU6)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_second_2fprotos_2factivations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SELU : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:second.protos.SELU) */ {
 public:
  SELU();
  virtual ~SELU();

  SELU(const SELU& from);

  inline SELU& operator=(const SELU& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SELU(SELU&& from) noexcept
    : SELU() {
    *this = ::std::move(from);
  }

  inline SELU& operator=(SELU&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SELU& default_instance();

  static inline const SELU* internal_default_instance() {
    return reinterpret_cast<const SELU*>(
               &_SELU_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(SELU* other);
  friend void swap(SELU& a, SELU& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SELU* New() const PROTOBUF_FINAL { return New(NULL); }

  SELU* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SELU& from);
  void MergeFrom(const SELU& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SELU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:second.protos.SELU)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_second_2fprotos_2factivations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Activation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:second.protos.Activation) */ {
 public:
  Activation();
  virtual ~Activation();

  Activation(const Activation& from);

  inline Activation& operator=(const Activation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Activation(Activation&& from) noexcept
    : Activation() {
    *this = ::std::move(from);
  }

  inline Activation& operator=(Activation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Activation& default_instance();

  enum ActivationCase {
    kRelu = 1,
    kLeakyRelu = 2,
    kSwish = 3,
    kElu = 4,
    kSoftplus = 5,
    kSoftsign = 6,
    kRelu6 = 7,
    kSelu = 8,
    ACTIVATION_NOT_SET = 0,
  };

  static inline const Activation* internal_default_instance() {
    return reinterpret_cast<const Activation*>(
               &_Activation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Activation* other);
  friend void swap(Activation& a, Activation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Activation* New() const PROTOBUF_FINAL { return New(NULL); }

  Activation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Activation& from);
  void MergeFrom(const Activation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Activation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .second.protos.ReLU relu = 1;
  bool has_relu() const;
  void clear_relu();
  static const int kReluFieldNumber = 1;
  const ::second::protos::ReLU& relu() const;
  ::second::protos::ReLU* mutable_relu();
  ::second::protos::ReLU* release_relu();
  void set_allocated_relu(::second::protos::ReLU* relu);

  // .second.protos.LeakyReLU leaky_relu = 2;
  bool has_leaky_relu() const;
  void clear_leaky_relu();
  static const int kLeakyReluFieldNumber = 2;
  const ::second::protos::LeakyReLU& leaky_relu() const;
  ::second::protos::LeakyReLU* mutable_leaky_relu();
  ::second::protos::LeakyReLU* release_leaky_relu();
  void set_allocated_leaky_relu(::second::protos::LeakyReLU* leaky_relu);

  // .second.protos.Swish swish = 3;
  bool has_swish() const;
  void clear_swish();
  static const int kSwishFieldNumber = 3;
  const ::second::protos::Swish& swish() const;
  ::second::protos::Swish* mutable_swish();
  ::second::protos::Swish* release_swish();
  void set_allocated_swish(::second::protos::Swish* swish);

  // .second.protos.ELU elu = 4;
  bool has_elu() const;
  void clear_elu();
  static const int kEluFieldNumber = 4;
  const ::second::protos::ELU& elu() const;
  ::second::protos::ELU* mutable_elu();
  ::second::protos::ELU* release_elu();
  void set_allocated_elu(::second::protos::ELU* elu);

  // .second.protos.Softplus softplus = 5;
  bool has_softplus() const;
  void clear_softplus();
  static const int kSoftplusFieldNumber = 5;
  const ::second::protos::Softplus& softplus() const;
  ::second::protos::Softplus* mutable_softplus();
  ::second::protos::Softplus* release_softplus();
  void set_allocated_softplus(::second::protos::Softplus* softplus);

  // .second.protos.Softsign softsign = 6;
  bool has_softsign() const;
  void clear_softsign();
  static const int kSoftsignFieldNumber = 6;
  const ::second::protos::Softsign& softsign() const;
  ::second::protos::Softsign* mutable_softsign();
  ::second::protos::Softsign* release_softsign();
  void set_allocated_softsign(::second::protos::Softsign* softsign);

  // .second.protos.ReLU6 relu6 = 7;
  bool has_relu6() const;
  void clear_relu6();
  static const int kRelu6FieldNumber = 7;
  const ::second::protos::ReLU6& relu6() const;
  ::second::protos::ReLU6* mutable_relu6();
  ::second::protos::ReLU6* release_relu6();
  void set_allocated_relu6(::second::protos::ReLU6* relu6);

  // .second.protos.SELU selu = 8;
  bool has_selu() const;
  void clear_selu();
  static const int kSeluFieldNumber = 8;
  const ::second::protos::SELU& selu() const;
  ::second::protos::SELU* mutable_selu();
  ::second::protos::SELU* release_selu();
  void set_allocated_selu(::second::protos::SELU* selu);

  ActivationCase activation_case() const;
  // @@protoc_insertion_point(class_scope:second.protos.Activation)
 private:
  void set_has_relu();
  void set_has_leaky_relu();
  void set_has_swish();
  void set_has_elu();
  void set_has_softplus();
  void set_has_softsign();
  void set_has_relu6();
  void set_has_selu();

  inline bool has_activation() const;
  void clear_activation();
  inline void clear_has_activation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ActivationUnion {
    ActivationUnion() {}
    ::second::protos::ReLU* relu_;
    ::second::protos::LeakyReLU* leaky_relu_;
    ::second::protos::Swish* swish_;
    ::second::protos::ELU* elu_;
    ::second::protos::Softplus* softplus_;
    ::second::protos::Softsign* softsign_;
    ::second::protos::ReLU6* relu6_;
    ::second::protos::SELU* selu_;
  } activation_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_second_2fprotos_2factivations_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ReLU

// -------------------------------------------------------------------

// LeakyReLU

// float leakness = 1;
inline void LeakyReLU::clear_leakness() {
  leakness_ = 0;
}
inline float LeakyReLU::leakness() const {
  // @@protoc_insertion_point(field_get:second.protos.LeakyReLU.leakness)
  return leakness_;
}
inline void LeakyReLU::set_leakness(float value) {
  
  leakness_ = value;
  // @@protoc_insertion_point(field_set:second.protos.LeakyReLU.leakness)
}

// -------------------------------------------------------------------

// Swish

// -------------------------------------------------------------------

// ELU

// float alpha = 1;
inline void ELU::clear_alpha() {
  alpha_ = 0;
}
inline float ELU::alpha() const {
  // @@protoc_insertion_point(field_get:second.protos.ELU.alpha)
  return alpha_;
}
inline void ELU::set_alpha(float value) {
  
  alpha_ = value;
  // @@protoc_insertion_point(field_set:second.protos.ELU.alpha)
}

// -------------------------------------------------------------------

// Softplus

// float beta = 1;
inline void Softplus::clear_beta() {
  beta_ = 0;
}
inline float Softplus::beta() const {
  // @@protoc_insertion_point(field_get:second.protos.Softplus.beta)
  return beta_;
}
inline void Softplus::set_beta(float value) {
  
  beta_ = value;
  // @@protoc_insertion_point(field_set:second.protos.Softplus.beta)
}

// float threshold = 2;
inline void Softplus::clear_threshold() {
  threshold_ = 0;
}
inline float Softplus::threshold() const {
  // @@protoc_insertion_point(field_get:second.protos.Softplus.threshold)
  return threshold_;
}
inline void Softplus::set_threshold(float value) {
  
  threshold_ = value;
  // @@protoc_insertion_point(field_set:second.protos.Softplus.threshold)
}

// -------------------------------------------------------------------

// Softsign

// -------------------------------------------------------------------

// ReLU6

// -------------------------------------------------------------------

// SELU

// -------------------------------------------------------------------

// Activation

// .second.protos.ReLU relu = 1;
inline bool Activation::has_relu() const {
  return activation_case() == kRelu;
}
inline void Activation::set_has_relu() {
  _oneof_case_[0] = kRelu;
}
inline void Activation::clear_relu() {
  if (has_relu()) {
    delete activation_.relu_;
    clear_has_activation();
  }
}
inline  const ::second::protos::ReLU& Activation::relu() const {
  // @@protoc_insertion_point(field_get:second.protos.Activation.relu)
  return has_relu()
      ? *activation_.relu_
      : ::second::protos::ReLU::default_instance();
}
inline ::second::protos::ReLU* Activation::mutable_relu() {
  if (!has_relu()) {
    clear_activation();
    set_has_relu();
    activation_.relu_ = new ::second::protos::ReLU;
  }
  // @@protoc_insertion_point(field_mutable:second.protos.Activation.relu)
  return activation_.relu_;
}
inline ::second::protos::ReLU* Activation::release_relu() {
  // @@protoc_insertion_point(field_release:second.protos.Activation.relu)
  if (has_relu()) {
    clear_has_activation();
    ::second::protos::ReLU* temp = activation_.relu_;
    activation_.relu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Activation::set_allocated_relu(::second::protos::ReLU* relu) {
  clear_activation();
  if (relu) {
    set_has_relu();
    activation_.relu_ = relu;
  }
  // @@protoc_insertion_point(field_set_allocated:second.protos.Activation.relu)
}

// .second.protos.LeakyReLU leaky_relu = 2;
inline bool Activation::has_leaky_relu() const {
  return activation_case() == kLeakyRelu;
}
inline void Activation::set_has_leaky_relu() {
  _oneof_case_[0] = kLeakyRelu;
}
inline void Activation::clear_leaky_relu() {
  if (has_leaky_relu()) {
    delete activation_.leaky_relu_;
    clear_has_activation();
  }
}
inline  const ::second::protos::LeakyReLU& Activation::leaky_relu() const {
  // @@protoc_insertion_point(field_get:second.protos.Activation.leaky_relu)
  return has_leaky_relu()
      ? *activation_.leaky_relu_
      : ::second::protos::LeakyReLU::default_instance();
}
inline ::second::protos::LeakyReLU* Activation::mutable_leaky_relu() {
  if (!has_leaky_relu()) {
    clear_activation();
    set_has_leaky_relu();
    activation_.leaky_relu_ = new ::second::protos::LeakyReLU;
  }
  // @@protoc_insertion_point(field_mutable:second.protos.Activation.leaky_relu)
  return activation_.leaky_relu_;
}
inline ::second::protos::LeakyReLU* Activation::release_leaky_relu() {
  // @@protoc_insertion_point(field_release:second.protos.Activation.leaky_relu)
  if (has_leaky_relu()) {
    clear_has_activation();
    ::second::protos::LeakyReLU* temp = activation_.leaky_relu_;
    activation_.leaky_relu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Activation::set_allocated_leaky_relu(::second::protos::LeakyReLU* leaky_relu) {
  clear_activation();
  if (leaky_relu) {
    set_has_leaky_relu();
    activation_.leaky_relu_ = leaky_relu;
  }
  // @@protoc_insertion_point(field_set_allocated:second.protos.Activation.leaky_relu)
}

// .second.protos.Swish swish = 3;
inline bool Activation::has_swish() const {
  return activation_case() == kSwish;
}
inline void Activation::set_has_swish() {
  _oneof_case_[0] = kSwish;
}
inline void Activation::clear_swish() {
  if (has_swish()) {
    delete activation_.swish_;
    clear_has_activation();
  }
}
inline  const ::second::protos::Swish& Activation::swish() const {
  // @@protoc_insertion_point(field_get:second.protos.Activation.swish)
  return has_swish()
      ? *activation_.swish_
      : ::second::protos::Swish::default_instance();
}
inline ::second::protos::Swish* Activation::mutable_swish() {
  if (!has_swish()) {
    clear_activation();
    set_has_swish();
    activation_.swish_ = new ::second::protos::Swish;
  }
  // @@protoc_insertion_point(field_mutable:second.protos.Activation.swish)
  return activation_.swish_;
}
inline ::second::protos::Swish* Activation::release_swish() {
  // @@protoc_insertion_point(field_release:second.protos.Activation.swish)
  if (has_swish()) {
    clear_has_activation();
    ::second::protos::Swish* temp = activation_.swish_;
    activation_.swish_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Activation::set_allocated_swish(::second::protos::Swish* swish) {
  clear_activation();
  if (swish) {
    set_has_swish();
    activation_.swish_ = swish;
  }
  // @@protoc_insertion_point(field_set_allocated:second.protos.Activation.swish)
}

// .second.protos.ELU elu = 4;
inline bool Activation::has_elu() const {
  return activation_case() == kElu;
}
inline void Activation::set_has_elu() {
  _oneof_case_[0] = kElu;
}
inline void Activation::clear_elu() {
  if (has_elu()) {
    delete activation_.elu_;
    clear_has_activation();
  }
}
inline  const ::second::protos::ELU& Activation::elu() const {
  // @@protoc_insertion_point(field_get:second.protos.Activation.elu)
  return has_elu()
      ? *activation_.elu_
      : ::second::protos::ELU::default_instance();
}
inline ::second::protos::ELU* Activation::mutable_elu() {
  if (!has_elu()) {
    clear_activation();
    set_has_elu();
    activation_.elu_ = new ::second::protos::ELU;
  }
  // @@protoc_insertion_point(field_mutable:second.protos.Activation.elu)
  return activation_.elu_;
}
inline ::second::protos::ELU* Activation::release_elu() {
  // @@protoc_insertion_point(field_release:second.protos.Activation.elu)
  if (has_elu()) {
    clear_has_activation();
    ::second::protos::ELU* temp = activation_.elu_;
    activation_.elu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Activation::set_allocated_elu(::second::protos::ELU* elu) {
  clear_activation();
  if (elu) {
    set_has_elu();
    activation_.elu_ = elu;
  }
  // @@protoc_insertion_point(field_set_allocated:second.protos.Activation.elu)
}

// .second.protos.Softplus softplus = 5;
inline bool Activation::has_softplus() const {
  return activation_case() == kSoftplus;
}
inline void Activation::set_has_softplus() {
  _oneof_case_[0] = kSoftplus;
}
inline void Activation::clear_softplus() {
  if (has_softplus()) {
    delete activation_.softplus_;
    clear_has_activation();
  }
}
inline  const ::second::protos::Softplus& Activation::softplus() const {
  // @@protoc_insertion_point(field_get:second.protos.Activation.softplus)
  return has_softplus()
      ? *activation_.softplus_
      : ::second::protos::Softplus::default_instance();
}
inline ::second::protos::Softplus* Activation::mutable_softplus() {
  if (!has_softplus()) {
    clear_activation();
    set_has_softplus();
    activation_.softplus_ = new ::second::protos::Softplus;
  }
  // @@protoc_insertion_point(field_mutable:second.protos.Activation.softplus)
  return activation_.softplus_;
}
inline ::second::protos::Softplus* Activation::release_softplus() {
  // @@protoc_insertion_point(field_release:second.protos.Activation.softplus)
  if (has_softplus()) {
    clear_has_activation();
    ::second::protos::Softplus* temp = activation_.softplus_;
    activation_.softplus_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Activation::set_allocated_softplus(::second::protos::Softplus* softplus) {
  clear_activation();
  if (softplus) {
    set_has_softplus();
    activation_.softplus_ = softplus;
  }
  // @@protoc_insertion_point(field_set_allocated:second.protos.Activation.softplus)
}

// .second.protos.Softsign softsign = 6;
inline bool Activation::has_softsign() const {
  return activation_case() == kSoftsign;
}
inline void Activation::set_has_softsign() {
  _oneof_case_[0] = kSoftsign;
}
inline void Activation::clear_softsign() {
  if (has_softsign()) {
    delete activation_.softsign_;
    clear_has_activation();
  }
}
inline  const ::second::protos::Softsign& Activation::softsign() const {
  // @@protoc_insertion_point(field_get:second.protos.Activation.softsign)
  return has_softsign()
      ? *activation_.softsign_
      : ::second::protos::Softsign::default_instance();
}
inline ::second::protos::Softsign* Activation::mutable_softsign() {
  if (!has_softsign()) {
    clear_activation();
    set_has_softsign();
    activation_.softsign_ = new ::second::protos::Softsign;
  }
  // @@protoc_insertion_point(field_mutable:second.protos.Activation.softsign)
  return activation_.softsign_;
}
inline ::second::protos::Softsign* Activation::release_softsign() {
  // @@protoc_insertion_point(field_release:second.protos.Activation.softsign)
  if (has_softsign()) {
    clear_has_activation();
    ::second::protos::Softsign* temp = activation_.softsign_;
    activation_.softsign_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Activation::set_allocated_softsign(::second::protos::Softsign* softsign) {
  clear_activation();
  if (softsign) {
    set_has_softsign();
    activation_.softsign_ = softsign;
  }
  // @@protoc_insertion_point(field_set_allocated:second.protos.Activation.softsign)
}

// .second.protos.ReLU6 relu6 = 7;
inline bool Activation::has_relu6() const {
  return activation_case() == kRelu6;
}
inline void Activation::set_has_relu6() {
  _oneof_case_[0] = kRelu6;
}
inline void Activation::clear_relu6() {
  if (has_relu6()) {
    delete activation_.relu6_;
    clear_has_activation();
  }
}
inline  const ::second::protos::ReLU6& Activation::relu6() const {
  // @@protoc_insertion_point(field_get:second.protos.Activation.relu6)
  return has_relu6()
      ? *activation_.relu6_
      : ::second::protos::ReLU6::default_instance();
}
inline ::second::protos::ReLU6* Activation::mutable_relu6() {
  if (!has_relu6()) {
    clear_activation();
    set_has_relu6();
    activation_.relu6_ = new ::second::protos::ReLU6;
  }
  // @@protoc_insertion_point(field_mutable:second.protos.Activation.relu6)
  return activation_.relu6_;
}
inline ::second::protos::ReLU6* Activation::release_relu6() {
  // @@protoc_insertion_point(field_release:second.protos.Activation.relu6)
  if (has_relu6()) {
    clear_has_activation();
    ::second::protos::ReLU6* temp = activation_.relu6_;
    activation_.relu6_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Activation::set_allocated_relu6(::second::protos::ReLU6* relu6) {
  clear_activation();
  if (relu6) {
    set_has_relu6();
    activation_.relu6_ = relu6;
  }
  // @@protoc_insertion_point(field_set_allocated:second.protos.Activation.relu6)
}

// .second.protos.SELU selu = 8;
inline bool Activation::has_selu() const {
  return activation_case() == kSelu;
}
inline void Activation::set_has_selu() {
  _oneof_case_[0] = kSelu;
}
inline void Activation::clear_selu() {
  if (has_selu()) {
    delete activation_.selu_;
    clear_has_activation();
  }
}
inline  const ::second::protos::SELU& Activation::selu() const {
  // @@protoc_insertion_point(field_get:second.protos.Activation.selu)
  return has_selu()
      ? *activation_.selu_
      : ::second::protos::SELU::default_instance();
}
inline ::second::protos::SELU* Activation::mutable_selu() {
  if (!has_selu()) {
    clear_activation();
    set_has_selu();
    activation_.selu_ = new ::second::protos::SELU;
  }
  // @@protoc_insertion_point(field_mutable:second.protos.Activation.selu)
  return activation_.selu_;
}
inline ::second::protos::SELU* Activation::release_selu() {
  // @@protoc_insertion_point(field_release:second.protos.Activation.selu)
  if (has_selu()) {
    clear_has_activation();
    ::second::protos::SELU* temp = activation_.selu_;
    activation_.selu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Activation::set_allocated_selu(::second::protos::SELU* selu) {
  clear_activation();
  if (selu) {
    set_has_selu();
    activation_.selu_ = selu;
  }
  // @@protoc_insertion_point(field_set_allocated:second.protos.Activation.selu)
}

inline bool Activation::has_activation() const {
  return activation_case() != ACTIVATION_NOT_SET;
}
inline void Activation::clear_has_activation() {
  _oneof_case_[0] = ACTIVATION_NOT_SET;
}
inline Activation::ActivationCase Activation::activation_case() const {
  return Activation::ActivationCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace protos
}  // namespace second

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_second_2fprotos_2factivations_2eproto__INCLUDED
